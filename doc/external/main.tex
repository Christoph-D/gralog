\documentclass{article}
\usepackage[margin=1.0in]{geometry}
\usepackage{longtable}

\usepackage{amsmath}

\newcounter{example}
\newenvironment{example}[1][]{\refstepcounter{example}\par\medskip
   \noindent \textit{Example~\theexample. #1} \rmfamily}{\medskip}

\usepackage{bbm}
\usepackage{booktabs}

\newcommand{\fabs}[1]{\mid {#1} \mid}



\newcommand{\bet}[1]{\llbracket {#1} \rrbracket^{\beta} }
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{makecell}
\usepackage[colorlinks = true,
            linkcolor = blue,
            urlcolor  = blue,
            citecolor = blue,
            anchorcolor = blue]{hyperref}

% \usepackage{mathabx}
\usepackage{amssymb,forest}

\usepackage{float}
\usepackage{MnSymbol}
\newlength\q
\newlength\smallCol
\newlength\argsLen
\setlength\q{\dimexpr .5\textwidth -2\tabcolsep}
\setlength\smallCol{\dimexpr .15\textwidth}
\setlength\argsLen{\dimexpr .2\textwidth}


\newcommand{\lto}{\mathbin{\to}}
\newcommand{\changeurlcolor}[1]{\hypersetup{urlcolor=#1}}   
\usepackage{booktabs}
\usepackage{enumitem} 
\usepackage{array}% for extended column definitions
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{tabto}
\newcommand{\ov}[2]{\ensuremath{\overset{\cdot {#2} \cdot}{#1}}}
\newcommand{\imp}{\rightarrow}

\usepackage{xstring}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}

\usepackage{lipsum}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\lstset{language=Python}

\title{Gralog External Programming Manual}

\author{Felix Herron\\\texttt{felix.herron@tu-berlin.de} \and Roman
  Rabinovich\\ \texttt{roman.rabinovich@tu-berlin.de}}

\date{August 2018}

\begin{document}

\maketitle


\begin{abstract}
Gralog is a visual tool for working with graphs, logics, games,
transition systems and other structures based on undirected and
directed graphs. It can create, load, save and edit graphs in
various formats.

The key focus of Gralog is simplicity of use and a short time of
learning how to use it.

A special property of Gralog is that it helps the developer to write
programmes for graphs in any language capable of working with
pipes. Gralog visualises the run of the programme and can keep track
of values of user defined variables.

The interaction between Gralog and the external programme is
performed by a simple, but powerful protocol. In the first version
we implemented a library for Python that simplifies the interaction
and abstracts away the use of pipes. This paper describes the
protocol and the library, the External Programming Module (EPM). This
includes documentation of methods and classes pertaining to the
EPM and code examples for how to use these.
\end{abstract}

\section{Documentation and Installation}

You can download Gralog from \url{www.gralog.org} (Change this)

Gralog is written in Java and does not need special installation. Just
run the jar file by

[code, including where the jar file is]

or run Gralog directly from the source code by calling

[code: ./gradlew].

The documentation can be found in directory \texttt{doc/}. The main
manual file is \texttt{gralog.pdf}. This part is additionally in the
file \texttt{external.pdf}. [TODO: make a general manual, include this
text there.]



\section{Setting up your External Python Program}
To link your script to Gralog, create a python file and import (all of) it. This is easiest (and \textit{recommended} if you want the provided code snippet to work) if the library and your script are in the same directory - python can be finicky about such things.\\

In the new file you created, paste the following code.


\begin{lstlisting}[title={Code Snippet 1},label=codeSnippet1]
#!/usr/bin/python
#HelloWorld.py
from Gralog import *
#A simple Gralog program which creates a vertex that says "Hello, world"

g = Graph(None); #uses the current graph that is open
v = g.addVertex();
v.setLabel("Hello, world!");
\end{lstlisting}

Now before you can run this code, open Gralog and select Preferences from the File menu. Navigate to General, then select the file you created at \emph{Ext. Prog. Source File}. Click \textbf{``Ok''.}

Now you should be ready to run. Navigate to File Menu and select "Load Plugin". What you should get is something that looks like this: 

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{helloWorld.png}
\end{figure}


\subsection{Troubleshooting}
First obviously make sure you have python installed (version $\ge
2.7$). Also make sure that Gralog.py is in the directory as the file you
wish to execute. Obviously you can mess around with the file structure
to fit your needs but in this configuration they must be in the same
directory. For other outstanding problems feel free to shoot an email
at \texttt{gralog@tu-berlin.de} (TODO: make the email address.)

\section{Introduction}
Now that you have the code running and set up, what will follow is a brief explanation of all of the functionality which we have built, structured in an intuitive manner.

\subsection{The Graph Class}
The first relevant class is Graph. In every program, you must choose a graph on which to execute your program. This is accomplished by instantiating the class Graph. 

\begin{lstlisting}
g = Graph();
\end{lstlisting}

In the constructor you specify which type of graph (directed,
undirected, a Kripke structure, a finite automaton, a BÃ¼chi automaton) you would like. No
argument means use the graph that is currently opened in Gralog, whatever (type) it may be.

The Graph class can be seen as the moderator of the program. You will use it to do all of the surface-level, more general commands pertaining to the graph itself. The more intricate details will be done using the following two:

\subsection{The Vertex Class}
Each vertex is represented as an object of the class Vertex. It is distinguished by its unique ID. 

\begin{lstlisting}
v = g.createVertex();
\end{lstlisting}

All methods pertaining to the individual vertices, such as their color, neighbours, or label, are most easily manipulated using methods of this class. For example:

\begin{lstlisting}
v = g.createVertex(id=42);
v.setLabel("f00");
neighbours = v.getNeighbours();
myLabel = v.getLabel();
v.delete();
\end{lstlisting}

\subsection{The Edge Class}
Each edge is represented as an object of hte Edge class. It is distinguished by its unique ID; however, in graphs without multi-edges, it can also be distinguished by its source and target vertices.

\begin{lstlisting}
e = g.createEdge(v1,v2,directed=False);
\end{lstlisting}

All methods pertaining to the individual edges, such as their color, adjacent edges, or label, are most easily manipulated using methods of this class. For example:

\begin{lstlisting}
e = g.createEdge(v1,v2,directed=False,id=451);
e.setLabel("f00");
adjacentEdges = e.getAdjacentEdges();
target = e.getTarget();
e.delete();
\end{lstlisting}

\subsection{Printing to the Console}
To print to the Gralog console, please use the method gPrint(str: message). Please note that this message must be a single-line string. No new-lines please!

\begin{lstlisting}
#!/usr/bin/python
#HelloWorld.py
from Gralog import *
g = Graph(None);
#end boiler plate

gPrint("hello world on the Gralog Console yeaaaahhh");
\end{lstlisting}

\section{Documentation}

\subsection{Class Graph}

\textbf{{\large Instance Variables}}


\begin{longtable}{p{\q}p{\q}}
Instance Variable & Meaning and Usage \\ \hline
\textbf{Dictionary} \textit{vertices} & A dictionary that holds all of the Vertex objects known to the graph. This should ideally not be changed by the programmer. \\\hline
\textbf{Dictionary} \textit{edges} & A dictionary that holds all of the Edge objects known to the graph. This should ideally not be changed by the programmer. \\\hline
\textbf{Integer} \textit{id} & The id of the graph that is used in communication with gralog. This should ideally not be changed by the programmer. \\ \hline
\textbf{Dictionary} \textit{variablesToTrack} & Objects in format (name,value). These are displayed in the Algorithm Control Panel. These may be changed. \\ \hline
\textbf{Dictionary} \textit{variablesToTrack} & Objects in format (name,value). These are displayed in the Algorithm Control Panel. These may be changed. \\ \hline
\end{longtable}


\textbf{{\large Relevant Methods}}
\textit{Note: optional parameters are in square brackets}


\begin{description}
\item[Graph({[str: format]})] \emph{returns} a Graph Object.\\\\
This is the constructor for the Graph class. It returns one of two things, depending on the parameter passed. If None is passed as the parameter, then \textit{no new graph is created}. Rather, the graph that is currently open in Gralog is passed to your program and a reference to it is stored in the Graph object. This Graph object now also contains all relevant (rudimentary) features of the open graph. The other parameter options are:
\begin{itemize}
\item nothing, e.g.\@ \texttt{g = Graph()}, (this is the default, which is interpreted as ''undirected")
\item \texttt{"{}undirected"},
\item \texttt{"directed"},
\item \texttt{"buechi"},
\item \texttt{"kripke"},
\item \texttt{"{}automaton"}.
\end{itemize}
\end{description}

Use of these parameters causes Gralog to create a new (empty) graph of the requested type, a reference to which is then passed back to your program and stored in the returned Graph object.
\subsection{Graph Manipulating Methods}
\textbf{Note:} every time a \texttt{Vertex} object is a function \textit{parameter}, the programmer may pass \textit{either} a \texttt{Vertex} object \textit{or} a valid vertex id; likewise for \texttt{Edge} objects as parameters and edge id's. In order to avoid redundancy, there are not duplicate method descriptions.

\begin{description}
\item[addVertex({[int: vertexId]}{[(double, double): pos]})]\emph{returns}
  \texttt{Vertex} object

  Creates a new \texttt{Vertex} object. If both coordinates coordinates in coordinate Vector \texttt{(x\_coord,y\_coord)} are \textit{not} passed,
  random coordinates are chosen
  %and the vertex is selected in
  %the Gralog UI.
  If no \texttt{vertexId} is passed, a suitable id is
  chosen by Gralog automatically. If an id is passed that has already
  been assigned, a suitable new one is silently chosen.
  
  The \texttt{vertex} returned has the final id assigned to it.
  
  \hyperref[addVertexExample]{Example}

  
\item[deleteVertex(Vertex: v)] \emph{returns} \texttt{void}

Deletes the given vertex from the graph. If the vertex does not exist, the program continues\footnote{you will however receive a warning message in the console \label{deleteVertexWarning}}


\item[addEdge(Vertex: source, Vertex target,{[int: egdeId]})] \emph{returns} \texttt{Edge} object


Creates a new \texttt{Edge} object from the source vertex to the
target vertex. The directedness of the Edge will correspond to the type of Graph the edge is being added to (directed Graph $\to$ directed edge, automaton $\to$ transition, etc.). If un-directed, the
order of target and source vertex is irrelevant. If no \texttt{edgeId}
is passed, a suitable id is chosen. If an id is passed that has
already been assigned, a suitable new one is silently chosen.


\item[deleteEdge(Edge: e)] \emph{returns} \texttt{void}

Deletes the edge from the graph. If the edge does not exist, nothing
happens.\textsuperscript{\ref{deleteVertexWarning}}


\item[deleteEdge((Vertex,Vertex): edge)] \emph{returns}
  \texttt{void} \footnote{make sure this is actually a tuple, or it will not work! Also note vertices and vertex id's can be mixed and matched, should that be practical, such that you could call g.edgeMethodFoo((Vertex,id)) or g.edgeMethodFoo((id,Vertex)) and they would be equivalent \label{makeSureATupleWarning1}}

  Deletes the edge with the greatest id from the list of all edges
  between the vertex in the first position of the tuple \texttt{edge} and the vertex which is the second position in tuple \texttt{source} respecting
  the direction if the graph has directed edges. If no such edge exists, nothing happens.


%\item[deleteEdge((int,int): edge)] \emph{returns}
%  \texttt{Boolean} \textsuperscript{\ref{makeSureATupleWarning1}}

  %Deletes the edge with the greatest id from the list of all edges
%  between the vertex whose \texttt{id} is the first element of tuple \texttt{edge}, and the vertex whose \texttt{id} is the second element of tuple \texttt{source} respecting
%  the direction if the graph has directed edges. If no such edge exists, nothing happens.

\item[existsEdge((Vertex,Vertex): edge)] \emph{returns}
  \texttt{void} \textsuperscript{\ref{makeSureATupleWarning1}}

  Returns whether there exists an edge between the first vertex of the tuple \texttt{edge} and the second (or from the first to the second in directed graphs).
  
  
\item[existsEdge(Edge: edge)] \emph{returns}
  \texttt{Boolean}

  Returns whether that specified edge (ie. the one with ID associated with the object) currently exists in the specified graph in Gralog. 
  
%\item[existsEdge(int: id)] \emph{returns}
%  \texttt{boolean}

%  Returns whether an edge with specified id currently exists in the specified graph in Gralog. 
  
\item[existsVertex(Vertex: vertex)] \emph{returns}
  \texttt{Boolean}

  Returns whether that specified Vertex (ie. the one with ID associated with the object) currently exists in the specified graph in Gralog. 
  
%\item[existsVertex(int: id)] \emph{returns}
%  \texttt{boolean}

%  Returns whether a Vertex with specified id currently exists in the specified graph in Gralog. 


\item[deleteAllEdges((Vertex,Vertex): vertexPair)] \emph{returns}
  \texttt{void}

  Deletes all edges in the graph
  between the vertex in the first position of the tuple \texttt{vertexPair} and the vertex which is the second position in tuple \texttt{vertexPair} respecting
  the direction if the graph has directed edges.
  If no such edges exist, nothing happens.
  
%\item[deleteAllEdges((int,int): vertexPair)] \emph{returns}
%  \texttt{void}

%  Deletes all edges
%  between the vertex whose \texttt{id} is the first element of tuple \texttt{edge}, and the vertex whose \texttt{id} is the second element of tuple \texttt{source} respecting
%  the direction if the graph has directed edges. If no such edges exist, nothing happens.
  
\end{description}

\subsection{Setter Functions}
\begin{description}
\item[setVertexFillColor(Vertex: v,{[int: colorHex]},{[(int,int,int): colorRGB]})]\emph{returns}
  \texttt{void}

Sets the \textit{fill} colour of the given \texttt{Vertex} to the Hex code colour
specified as a string or the RGB colour specified. colorHex can also be
a string of a common colour, such as \texttt{"red"} or
\texttt{"green."} \hyperref[colorNamesSupportedByGralog]{Full list of gralog supported color names}

Note that one of the two optional color parameters \textit{must} be filled, and both of them \textit{cannot} be filled.

\hyperref[colorNamesSupportedByGralog]{Color setting example}

\item[setVertexStrokeColor(Vertex: v,{[int: colorHex]},{[(int,int,int): colorRGB]}))] \emph{returns} \texttt{void}

Sets the \textit{stroke} colour of the given \texttt{Vertex} to the Hex code colour
specified as a string or the RGB colour specified. colorHex can also be
a string of a common colour, such as \texttt{"red"} or
\texttt{"green."} \hyperref[colorNamesSupportedByGralog]{Full list of gralog supported color names}

Note that one of the two optional color parameters \textit{must} be filled, and both of them \textit{cannot} be filled.

\hyperref[colorNamesSupportedByGralog]{Color setting example}

\item[setEdgeContour(Edge: edge, str: contour)] \emph{returns}
\texttt{void}

Sets the contour of passed \texttt{Edge}. Possible values are
\texttt{"dashed"}, \texttt{"dotted"}, \texttt{"plain"}.

\item[setEdgeColor(Edge: v, {[int: colorHex]},{[(int,int,int): colorRGB]}))] \emph{returns} \texttt{void}

Sets the colour of the given \texttt{Edge} to the Hex code colour
specified as a string or the RGB colour specified. colorHex can also be
a string of a common colour, such as \texttt{"red"} or
\texttt{"green."} \hyperref[colorNamesSupportedByGralog]{Full list of gralog supported color names}

Note that one of the two optional color parameters \textit{must} be filled, and both of them \textit{cannot} be filled.

\hyperref[colorNamesSupportedByGralog]{Color setting example}

\item[setVertexRadius(Vertex: v, float: radius)] \emph{returns}
  \texttt{void}

Sets the radius (ie width and height) of the given vertex shape to \texttt{radius}.

\item[setVertexHeight(Vertex: v, float: height)] \emph{returns}
  \texttt{void}

Sets the height of the given vertex to \texttt{height}.

\item[setVertexWidth(Vertex: v, float: width)] \emph{returns}
  \texttt{void}

Sets the width of the given vertex to \texttt{width}. 

\hyperref[radiusWidthHeightDiagram]{\textit{An explanation of width, height, and radius}}

  
\item[setVertexDimension(Vertex: v, float: width, str: dimension)]
  \emph{returns} \texttt{void}

Sets the dimension of the given vertex to the dimension specified. This functionality is primarily useful for non-standard shapes, if you were to extend gralog to include such a thing. Other than in this case, it is recommended that you use the built-in functions.

\item[setVertexShape(Vertex: v, str: shape)] \emph{returns} \texttt{void}

Sets the given vertex to be the specified shape. Currently supported
are ``\texttt{ellipse"}, \texttt{"diamond"}, and \texttt{"rectangle"}.

\item[setEdgeWeight(Edge: e, float: weight)] \emph{returns} \texttt{void}

Sets edge weight to \texttt{weight}. Not to be confused with setEdgeThickness

\item[setEdgeThickness(Edge: e, float: thiccness)] \emph{returns} \texttt{void}

Sets edge thiccness to \texttt{thiccness}. Not to be confused with setEdgeWeight

\item[setVertexLabel(Vertex: v, str: label)] \emph{returns} \texttt{void}

Sets the edge's label to the \texttt{label}

\item[setEdgeLabel(Edge: v, str: label)] \emph{returns} \texttt{void}

Sets the vertex's label to the \texttt{label}
  
\end{description}

\subsection{Setter Functions}
\begin{description}
\item[getGraph(str: graphFormat)]\emph{returns}
  \texttt{str}

Returns a string representation of the graph. Several formats are supported: GraphXML (parameter "XML"), TikZ (parameter "tikz"), Trivial Graph Format (paramter "TGF"), and Gralog Trivial Graph Format (pamater "GTGF"). \hyperref[graphFormatsInDetail]{Read more about them here}.

This is useful in at least the following two scenarios: 1: to take the graph Gralog has given, and import it into an external library for processing there (such as NetworkX, or TODO: another popular library). 2: to copy the contents of one graph into another Gralog graph. \hyperref[getGraphExample]{See an example here}.

\item[getAllVertices()]\emph{returns}
  \texttt{list of Vertex objects}

Returns a list of all the vertices in the graph.


\item[getAllVertices()]\emph{returns}
  \texttt{list of Vertex objects}

Returns a list of all the vertices in the graph.

\item[getAllEdges()]\emph{returns}
  \texttt{list of Edge objects}

Returns a list of all the edges graph.

\item[getNeighbours(Vertex: vertex)]\emph{returns}
  \texttt{list of Vertex objects}

Returns a list of all the vertices connected to \texttt{vertex}, regardless of direction.

\item[getOutgoingNeighbours(Vertex: vertex)]\emph{returns}
  \texttt{list of Vertex objects}

Returns a list of all the vertices v' such that there is an edge from \texttt{Vertex} to v' in directed graphs (equivalent to getNeighbours in undirected graphs)

\item[getIncomingNeighbours(Vertex: vertex)]\emph{returns}
  \texttt{list of Vertex objects}

Returns a list of all the vertices v' such that there is an edge from v' to \texttt{Vertex} in directed graphs (equivalent to getNeighbours in undirected graphs)

\end{description}

\section{Code Examples}

\begin{description}
\item[addVertex({[int: vertexId]}{[(double: x\_coord, double: y\_coord)]})]\emph{returns}
  \texttt{Vertex} object


  \begin{example}
    \begin{lstlisting}[title={addVertex Example},label=addVertexExample]
    #!/usr/bin/python
    #HelloWorld.py
    from Gralog import *
    g = Graph(None);
    #end boiler plate
    
    v = g.addVertex(); #adds a vertex with a random id and random coordinates
    v.setLabel("v: " + str(v.getId()));#shows the id gralog assigned on the vertex in Gralog
    
    v1 = g.addVertex(420);
    v1.setLabel("v1: " + str(v1.getId()));
    
    v2 = g.addVertex((-10,2.2)); #adds a vertex at (0,2.2) and random id*
    v2.setLabel("v2: " + str(v2.getId()));
    
    v3 = g.addVertex(0,(11,-3)); #adds a vertex at (11,-3) with id=0
    v3.setLabel("v3: " + str(v3.getId()));
    
    g.pause();
    
    #now we try and add a new vertex with an id that is in use
    
    vDuplicate = g.addVertex(420);
    vDuplicate.setLabel("dup: " + str(vDuplicate.getId())); #it ends up not being 420
    
    \end{lstlisting}
    *technically this should be \texttt{v2 = g.addVertex(pos=(0,2.2))}; however, in order to make it user friendly the library allows for the user to misuse parameters in order to preserve clarity and brevity
  \end{example}

\item[Color Setting examples]


  \begin{example}
    \begin{lstlisting}[title={Color Setting Example},label=colorSettingExample]
    #!/usr/bin/python
    #HelloWorld.py
    from Gralog import *
    g = Graph("directed");
    #end boiler plate
    
    v = g.addVertex();
    v.setColor("PUCE");
    g.pause();
    v.setColor(colorHex="123456");
    g.pause();
    v.setColor(colorRGB = (255,255,255));
    g.pause();
    v.setStrokeColor("red");
    g.pause();
    v.setStrokeColor("#101010");
    g.pause();
    v.setStrokeColor(colorRGB = (1,2,3));
    g.pause();
    v2 = g.addVertex();
    e = g.addEdge(v,v2);
    e.setColor("green");
    g.pause();
    e.setColor(colorHex="99999f");
    g.pause();
    e.setColor(colorRGB = (23,45,131));
    #the following will not work
    e.setColor((23,45,131));
    \end{lstlisting}
  \end{example}
  

\item[Color Setting examples]


  \begin{example}
    \begin{lstlisting}[title={getGraph Example},label=Example]
    #!/usr/bin/python
    #Showing how to load a graph from python into a string, then transfer it to another graph
    from Gralog import *
    g = Graph("directed");
    g2 = Graph("directed");
    #end boiler plate
    
    #populate g with 10 vertices in random locations
    for x in range(10):
      g.addVertex();
    
    gString = g.getGraph("GTGF");#load g into a string
    g2.setGraph("GTGF",gString);#set g2 to graph isomorphic to g
    \end{lstlisting}
  \end{example}
\end{description}

\begin{figure}[H]
\title{An explanation of the width, height, and radius properties of a \texttt{Vertex} object}
\label{radiusWidthHeightDiagram}
\centering
\includegraphics[width=200pt]{radiusWidthHeightDiagram.png}
\end{figure}

\section{Appendix}


\begin{table}[h!]
  \begin{center}
    \caption{Color Names supported by Gralog}
    \label{colorNamesSupportedByGralog}
    \begin{tabular}{c|c} % <-- Alignments: 1st column left, 2nd middle and 3rd right, with vertical lines in between
      \textbf{Gralog color name} & \textbf{Hex Value}\\
      WHITE   &\#FFFFFF\\
\hline
BLACK   &\#000000\\
\hline
BLUE    &\#0000FF\\
\hline
GREEN   &\#00FF00\\
\hline
RED     &\#FF0000\\
\hline
GRAY    &\#808080\\
\hline
YELLOW  &\#FFFF00\\
\hline
CYAN    &\#00FFFF\\
\hline
MAGENTA &\#FF00FF\\
\hline
SILVER  &\#C0C0C0\\
\hline
MAROON  &\#800000\\
\hline
OLIVE &\#808000\\
\hline
DARK GREEN &\#008000\\
\hline
PURPLE  &\#800080\\
\hline
TEAL  &\#008080\\
\hline
NAVY    &\#000080\\
\hline
ORANGE  &\#FF4500
    \end{tabular}
  \end{center}
\end{table}

\subsection{Graph formats in detail}
\label{graphFormatsInDetail}
The four graph formats Gralog supports are the following: \href{https://en.wikipedia.org/wiki/GraphML}{GraphML}, \href{https://en.wikipedia.org/wiki/Trivial\_Graph\_Format}{Trivial Graph Format}, \href{https://en.wikipedia.org/wiki/PGF/TikZ}{TikZ}, and Gralog Trivial Graph Format. The first three are cross-platform compatible with other libraries, and can be imported and exported easily with the Gralog Python library. The last is primarily useful for intra-gralog communication. It is a simple extension of TGF, that introduces edge id's in the format. This allows simple graphs to be passed between the Gralog Python programs and Gralog without losing any basic data that cannot be retrieved. The locations, colors, labels, weights etc. are not preserved in this format (hence trivial) but for simple uses it is quick and practical.

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
