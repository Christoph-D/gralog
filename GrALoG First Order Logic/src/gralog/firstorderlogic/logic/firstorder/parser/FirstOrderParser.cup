package gralog.firstorderlogic.logic.firstorder.parser;

import java_cup.runtime.*;
import gralog.firstorderlogic.logic.firstorder.formula.*;
import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.List;


parser code {:

    String errorMsg = null;
    private String inputString;

    public Boolean hasError()
    {
        return errorMsg == null;
    }
    
    public String getErrorMsg()
    {
        if(errorMsg == null)
            return "no error";
        else
            return errorMsg;
    }
    

    public void report_error(String message, Object info) {
        java_cup.runtime.ComplexSymbolFactory.ComplexSymbol symbol = (java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)info;
        String goodPrefix = inputString.substring(0, symbol.xleft.getColumn());
        String badSuffix = inputString.substring(symbol.xleft.getColumn());
        System.err.println("Parse error: Unexpected " + symbol.getName() + " at " + goodPrefix + " <HERE> " + badSuffix);
    }

    public void syntax_error(Symbol cur_token)
    {
        if(errorMsg == null)
            errorMsg = "Syntax Error: " + cur_token.toString();
    }

    public void report_fatal_error(String message, Object info) throws Exception
    {
        report_error(message, info);
    }

    public FirstOrderFormula parseString(String str) throws Exception
    {
        String charset = "UTF8";
        byte[] bytes = str.getBytes(charset);
        ByteArrayInputStream stringstream = new ByteArrayInputStream(bytes);

        inputString = str;
        FirstOrderScanner scanner = new FirstOrderScanner(stringstream);
        this.setScanner(scanner);

        Symbol parserresult = this.parse();
        return (FirstOrderFormula) parserresult.value;
    }
:}

terminal OPEN, CLOSE;      // "(", ")"
terminal NEG, AND, OR;     // \neg, \wedge, \vee
terminal EXISTS, FORALL;   // \exists \forall
terminal COMMA, DOT;       // ",", "."
terminal String STRING;

non terminal FirstOrderFormula formula;
non terminal FirstOrderFormula quantifiedformula;
non terminal FirstOrderFormula basicformula;
non terminal FirstOrderFormula disjunction;
non terminal FirstOrderFormula conjunction;
non terminal List<String> parameters;

formula ::=
    quantifiedformula:f
        {: RESULT = f; :}
    | disjunction:left OR quantifiedformula:right
        {: RESULT = new FirstOrderOr(left, right); :}
    | conjunction:left AND quantifiedformula:right
        {: RESULT = new FirstOrderAnd(left, right); :}
    | disjunction:left OR conjunction:middle AND quantifiedformula:right
        {: RESULT = new FirstOrderOr(left, new FirstOrderAnd(middle, right)); :}
    | disjunction:f
        {: RESULT = f; :}
    ;

disjunction ::=
    disjunction:left OR conjunction:right
        {: RESULT = new FirstOrderOr(left, right); :}
    | conjunction:f
        {: RESULT = f; :}
    ;

conjunction ::=
    conjunction:left AND basicformula:right
        {: RESULT = new FirstOrderAnd(left, right); :}
    | basicformula:f
        {: RESULT = f; :}
    ;

basicformula ::=
    NEG basicformula:f
        {: RESULT = new FirstOrderNot(f); :}
    | OPEN formula:f CLOSE
        {: RESULT = f; :}
    | STRING:rel OPEN parameters:params CLOSE
        {: RESULT = new FirstOrderRelation(rel, params); :}
    ;

quantifiedformula ::=
    NEG quantifiedformula:f
        {: RESULT = new FirstOrderNot(f); :}
    | EXISTS STRING:var DOT formula:f
        {: RESULT = new FirstOrderExists(var, f); :}
    | EXISTS STRING:var formula:f
        {: RESULT = new FirstOrderExists(var, f); :}
    | FORALL STRING:var DOT formula:f
        {: RESULT = new FirstOrderForall(var, f); :}
    | FORALL STRING:var formula:f
        {: RESULT = new FirstOrderForall(var, f); :}
    ;

parameters ::=
    STRING:s
        {: RESULT = new ArrayList<String>(); RESULT.add(s); :}
    | parameters:params COMMA STRING:s
        {: RESULT = params; RESULT.add(s); :}
    ;
